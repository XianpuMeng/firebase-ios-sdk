#!/usr/bin/env python3
#
# Copyright 2020 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Verifies includes where defines from cmake configure_files are used.

This script scans files that are used as the input for a cmake `configure_file`
command and enumerates the `cmakedefine` declarations. It then scans the source
code to ensure that all files that make use of those defines #include the header
file generated by the `configure_file` command.

For details about the cmake `configure_file` command see
https://cmake.org/cmake/help/latest/command/configure_file.html
"""

import re
import pathlib
import sys
from typing import Collection, FrozenSet, Mapping, Set, Tuple


class ConfigureFileParserParseResult:
  """Stores the result of parsing a `configure_file` file."""

  def __init__(self, defines: FrozenSet[str]) -> None:
    """
    Arguments:
      defines: The names of the variables created by #cmakedefine.
    """
    self.defines = defines


class ConfigureFileParser:
  """Parses a cmake `configure_file` file, enumerating its defines."""

  def __init__(self, path: pathlib.Path) -> None:
    """
    Arguments:
      path: The file to parse.
    """
    self.path = path

  def parse(self) -> ConfigureFileParserParseResult:
    """Parse the file.

    Returns: The data parsed from the file.
    """
    defines = set()

    define_pattern = re.compile(r"#cmakedefine\s+(?P<name>[^\s]+)")

    with self.path.open("rt", encoding="utf8") as f:
      for line in f:
        match = define_pattern.match(line)
        if match:
          defines.add(match.group("name"))

    return ConfigureFileParserParseResult(defines=frozenset(defines))


class CppFileParserResult:
  """Stores the result of parsing a C++ file."""

  def __init__(
      self,
      includes: FrozenSet[str],
      defines_used: Mapping[str, int],
  ) -> None:
    """
    Arguments:
      includes: The paths of the files included by #include.
      defines_used: The preprocessor variables used; the keys are the defines
        and the corresponding values are the line numbers.
    """
    self.includes = includes
    self.defines_used = defines_used


class CppFileParser:
  """Parser for C++ files to get the #include directives #define variables."""

  def __init__(self, path: pathlib.Path) -> None:
    """
    Arguments:
      path: The file to parse.
    """
    self.path = path

  def parse(self) -> CppFileParserResult:
    """Parse the file.

    Returns: The data parsed from the file.
    """
    includes = set()
    defines_used = {}

    include_pattern = re.compile(r"#(?i:include)\s+\"(?P<path>.+)\"$")
    directive_pattern = re.compile(r"#\s*(?P<cmd>\w+)\s+(?P<var>\w+)")

    with self.path.open("rt", encoding="utf8") as f:
      line_number = 0
      for line in f:
        line_number += 1
        include_match = include_pattern.match(line)
        if include_match:
          includes.add(include_match.group("path"))
          continue

        define_match = directive_pattern.match(line)
        if define_match:
          directive_name = define_match.group("cmd")
          if directive_name.lower() == "define":
            continue
          define_value = define_match.group("var")
          if define_value not in defines_used:
            defines_used[define_value] = line_number

    return CppFileParserResult(
        includes=frozenset(includes),
        defines_used=defines_used,
    )


class MissingInclude:
  """Stores information about a missing include."""

  def __init__(self, define: str, include: str, line_number: int) -> None:
    self.define = define
    self.include = include
    self.line_number = line_number

  def __eq__(self, other) -> bool:
    try:
      other_define = other.define
      other_include = other.include
      other_line_number = other.line_number
    except AttributeError:
      return False
    else:
      del other  # Guard against accidentally referencing "other".
      return (
        self.define == other_define and
        self.include == other_include and
        self.line_number == other_line_number
      )

  def __str__(self) -> str:
    return (
      f"Line {self.line_number}: "
      f"The include for {self.define} is missing: {self.include}"
    )

  def __repr__(self) -> str:
    return (
      "MissingInclude("
      f"define={self.define!r}, "
      f"include={self.include!r}, "
      f"line_number={self.line_number!r}"
      ")"
    )


class RequiredIncludesChecker:
  """Scans files for required includes for the defines that they use."""

  def __init__(self, defines: Mapping[str, str]) -> None:
    """
    Arguments:
      defines: The defines to verify have the correct includes; the keys of this
        mapping are the defines and the corresponding value is the required
        include for that define.
    """
    self.defines = defines

  def check_file(self, path: pathlib.Path) -> Tuple[MissingInclude]:
    """Checks the given file for missing includes.

    Arguments:
      path: The file to check.

    Returns:
      The missing includes; if empty then there were no missing includes and the
      check was successful; otherwise, each element describes an occurrence of
      a missing include.
    """
    cpp_file_parser = CppFileParser(path)
    parsed_cpp_file = cpp_file_parser.parse()

    missing_includes = []
    for define in parsed_cpp_file.defines_used:
      required_include = self.defines.get(define)
      if (required_include is not None and
          required_include not in parsed_cpp_file.includes):
        missing_include = MissingInclude(
          define=define,
          include=required_include,
          line_number=parsed_cpp_file.defines_used[define],
        )
        missing_includes.append(missing_include)

    return tuple(missing_includes)


class Config:
  """The configuration for this application."""

  def __init__(
      self,
      cmake_configure_files: Mapping[pathlib.Path, str],
      files_to_scan: Collection[pathlib.Path],
  ) -> None:
    self.cmake_configure_files = cmake_configure_files
    self.files_to_scan = files_to_scan


class ConfigBuilder:
  """Builds a `Config` object for this application."""

  def __init__(self) -> None:
    self.cmake_configure_files: Mapping[pathlib.Path, str] = {}
    self.files_to_scan: Set[pathlib.Path] = set()

  def build(self) -> Config:
    """Creates a new `Config` object from the information in this object.

    Returns: A newly-created Config object.
    """
    return Config(
      cmake_configure_files=dict(self.cmake_configure_files),
      files_to_scan=frozenset(self.files_to_scan),
    )

  def add_cmake_config_path(
      self,
      path: pathlib.Path,
      required_include: str,
  ) -> None:
    """Adds information about a cmake configure_file.

    This file will be parsed so that the sources can be verified to include the
    correct files.

    Arguments:
      path: The path of the cmake configure_file file.
      required_include: The required #include string for using cmakedefine
        declarations defined in the configure_file.
    """
    self.cmake_configure_files[path] = required_include

  def add_file_to_scan(
      self,
      path: pathlib.Path,
  ) -> None:
    """Adds a file to scan for correct usage of the cmake configure_file.

    Arguments:
      path: The file to scan.
    """
    self.files_to_scan.add(path)


def run(config: Config) -> int:
  defines = {}
  for cmake_configure_file in config.cmake_configure_files:
    required_include = config.cmake_configure_files[cmake_configure_file]
    configure_file_parser = ConfigureFileParser(cmake_configure_file)
    configure_file = configure_file_parser.parse()
    for define in configure_file.defines:
      defines[define] = required_include

  src_file_count = 0
  error_count = 0

  required_includes_checker = RequiredIncludesChecker(defines)
  for src_file in config.files_to_scan:
    src_file_count += 1
    missing_includes = required_includes_checker.check_file(src_file)
    for missing_include in missing_includes:
      error_count += 1
      print(
        f"ERROR: {src_file}:{missing_include.line_number} "
        f"{missing_include.define} is used but the required include for it "
        f"is missing: {missing_include.include}"
      )

  print(f"Scanned {src_file_count} files; {error_count} error(s) found.")
  return error_count


def main() -> int:
  config_builder = ConfigBuilder()
  config_builder.add_cmake_config_path(
    path=pathlib.Path("Firestore/core/src/util/config.h.in"),
    required_include="Firestore/core/src/util/config.h",
  )

  src_root_dir = pathlib.Path("Firestore")
  cc_files = src_root_dir.glob("**/*.cc")
  mm_files = src_root_dir.glob("**/*.mm")
  h_files = src_root_dir.glob("**/*.h")
  src_paths = list(cc_files) + list(mm_files) + list(h_files)
  for src_file in sorted(src_paths):
    config_builder.add_file_to_scan(src_file)

  error_count = run(config_builder.build())
  return 0 if error_count == 0 else 1


if __name__ == "__main__":
  exit_code = main()
  sys.exit(exit_code)
